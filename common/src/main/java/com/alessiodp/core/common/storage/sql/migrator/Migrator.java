package com.alessiodp.core.common.storage.sql.migrator;

import com.alessiodp.core.common.ADPPlugin;
import com.alessiodp.core.common.configuration.Constants;
import com.alessiodp.core.common.storage.sql.dao.SchemaHistoryDao;
import com.alessiodp.core.common.storage.sql.dao.SchemaHistoryH2Dao;
import com.alessiodp.core.common.storage.sql.dao.SchemaHistoryMySQLDao;
import com.alessiodp.core.common.storage.sql.dao.SchemaHistorySQLiteDao;
import lombok.Getter;
import lombok.NonNull;
import org.reflections.Reflections;
import org.reflections.scanners.ResourcesScanner;
import org.simpleyaml.utils.Validate;

import java.util.Optional;
import java.util.TreeSet;
import java.util.regex.Pattern;

public class Migrator {
	private MigratorConfiguration configuration;
	@Getter private TreeSet<FileParser> scripts;
	
	public Migrator(@NonNull MigratorConfiguration configuration) {
		this.configuration = configuration;
		scripts = new TreeSet<>();
	}
	
	/**
	 * Initialize a new MigratorConfiguration
	 *
	 * @return an initialized MigratorConfiguration
	 */
	public static MigratorConfiguration configure() {
		return new MigratorConfiguration();
	}
	
	/**
	 * Search for every script in the location
	 */
	public void searchScripts() {
		try {
			Reflections reflections = new Reflections(configuration.getLocation(), new ResourcesScanner());
			for (String resource : reflections.getResources(Pattern.compile(".*\\.sql"))) {
				String name = resource.substring(resource.lastIndexOf("/") + 1);
				FileParser fp = new FileParser(
						ADPPlugin.getInstance().getResource(resource),
						name
				);
				fp.parse();
				scripts.add(fp);
				
			}
		} catch (Exception ex) {
			ex.printStackTrace();
		}
	}
	
	/**
	 * Start the migration
	 */
	public void migrate() {
		Validate.notNull(configuration, "The migrator configuration cannot be null");
		Validate.notNull(configuration.getConnectionFactory(), "The migrator connection factory cannot be null");
		Validate.notNull(configuration.getStorageType(), "The migrator storage type cannot be null");
		searchScripts();
		
		configuration.getConnectionFactory().getJdbi().useTransaction(transaction -> {
			SchemaHistoryDao dao = transaction.attach(getSchemaHistoryDao());
			
			int version = -1;
			try {
				version = dao.higherVersion();
			} catch (Exception ex) {
				ADPPlugin.getInstance().getLoggerManager().logDebug(Constants.DEBUG_DB_MIGRATOR_CREATING_TABLE, true);
				dao.create();
			}
			
			// Check for old migrations
			if (configuration.getBackwardMigration() >= 0 && version == -1) {
				Optional<FileParser> fp = scripts.stream()
						.filter((c) -> c.getVersion() == configuration.getBackwardMigration())
						.findFirst();
				if (fp.isPresent()) {
					fp.get().getQueries().forEach(query -> transaction.execute(query));
					version = configuration.getBackwardMigration();
				} else {
					throw new MissingMigrationTableException(String.format("Missing migration table number %d for backward compatibility", configuration.getBackwardMigration()));
				}
			}
			
			for (FileParser fp : scripts) {
				if (fp.getVersion() > version && fp.getVersion() >= configuration.getStartMigration()) {
					ADPPlugin.getInstance().getLoggerManager().logDebug(Constants.DEBUG_DB_MIGRATOR_MIGRATING
							.replace("{file}", fp.getScriptName()), true);
					fp.getQueries().forEach(query -> transaction.execute(query));
					
					dao.insert(fp.getVersion(), fp.getDescription(), fp.getScriptName(), System.currentTimeMillis() / 1000);
				}
			}
		});
	}
	
	private Class<? extends SchemaHistoryDao> getSchemaHistoryDao() {
		switch (configuration.getStorageType()) {
			case MYSQL:
				return SchemaHistoryMySQLDao.class;
			case SQLITE:
				return SchemaHistorySQLiteDao.class;
			case H2:
				return SchemaHistoryH2Dao.class;
			default:
				return null;
		}
	}
	
	/**
	 * Exception generated by missing migration table
	 */
	public static class MissingMigrationTableException extends RuntimeException {
		MissingMigrationTableException(String text) {
			super(text);
		}
	}
}
