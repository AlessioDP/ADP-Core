package com.alessiodp.core.common.storage.sql.migrator;

import com.alessiodp.core.common.ADPPlugin;
import com.alessiodp.core.common.configuration.Constants;
import com.alessiodp.core.common.storage.dispatchers.SQLDispatcher;
import com.alessiodp.core.common.storage.sql.dao.SchemaHistoryDao;
import com.alessiodp.core.common.storage.sql.dao.SchemaHistoryH2Dao;
import com.alessiodp.core.common.storage.sql.dao.SchemaHistoryMariaDBDao;
import com.alessiodp.core.common.storage.sql.dao.SchemaHistoryMySQLDao;
import com.alessiodp.core.common.storage.sql.dao.SchemaHistoryPostgreSQLDao;
import com.alessiodp.core.common.storage.sql.dao.SchemaHistorySQLiteDao;
import lombok.Getter;
import lombok.NonNull;
import org.simpleyaml.utils.Validate;

import java.util.Optional;
import java.util.TreeSet;

public class Migrator {
	private SQLDispatcher dispatcher;
	private MigratorConfiguration configuration;
	@Getter private TreeSet<FileParser> scripts;
	
	public Migrator(@NonNull SQLDispatcher dispatcher, @NonNull MigratorConfiguration configuration) {
		this.dispatcher = dispatcher;
		this.configuration = configuration;
		scripts = new TreeSet<>();
	}
	
	/**
	 * Initialize a new MigratorConfiguration
	 *
	 * @return an initialized MigratorConfiguration
	 */
	public static MigratorConfiguration configure() {
		return new MigratorConfiguration();
	}
	
	/**
	 * Start the migration
	 */
	public void migrate() {
		Validate.notNull(configuration, "The migrator configuration cannot be null");
		Validate.notNull(configuration.getConnectionFactory(), "The migrator connection factory cannot be null");
		Validate.notNull(configuration.getStorageType(), "The migrator storage type cannot be null");
		Validate.notNull(getSchemaHistoryDao(), "The schema history dao cannot be null");
		Validate.notEmpty(configuration.getScripts(), "The migrator configuration scripts cannot be empty");
		parseScripts();
		
		configuration.getConnectionFactory().getJdbi().useTransaction(transaction -> {
			SchemaHistoryDao dao = transaction.attach(getSchemaHistoryDao());
			
			dao.create();
			
			int version = 0;
			try {
				version = dao.higherVersion();
			} catch (Exception ex) {
				// Try to re-create the table (not working on PostgreSQL)
				ADPPlugin.getInstance().getLoggerManager().logDebug(Constants.DEBUG_DB_MIGRATOR_CREATING_TABLE, true);
				dao.create();
			}
			
			// Check for old migrations
			if (configuration.getBackwardMigration() >= 0 && version == 0) {
				Optional<FileParser> fp = scripts.stream()
						.filter((c) -> c.getVersion() == configuration.getBackwardMigration())
						.findFirst();
				if (fp.isPresent()) {
					dispatcher.performMigration(transaction, fp.get().getQueries(), version);
					version = configuration.getBackwardMigration();
				} else {
					throw new MissingMigrationTableException(String.format("Missing migration table number %d for backward compatibility", configuration.getBackwardMigration()));
				}
			}
			
			for (FileParser fp : scripts) {
				if (fp.getVersion() > version && fp.getVersion() >= configuration.getStartMigration()) {
					ADPPlugin.getInstance().getLoggerManager().logDebug(String.format(Constants.DEBUG_DB_MIGRATOR_MIGRATING, fp.getScriptName()), true);
					fp.getQueries().forEach(query -> transaction.execute(query));
					
					dao.insert(fp.getVersion(), fp.getDescription(), fp.getScriptName(), System.currentTimeMillis() / 1000);
				}
			}
		});
	}
	
	/**
	 * Parse every script in the location
	 */
	public void parseScripts() {
		try {
			for (String script : configuration.getScripts()) {
				FileParser fp = new FileParser(
						ADPPlugin.getInstance().getResource(configuration.getLocation() + script),
						script
				);
				fp.parse();
				scripts.add(fp);
			}
		} catch (Exception ex) {
			ex.printStackTrace();
		}
	}
	
	private Class<? extends SchemaHistoryDao> getSchemaHistoryDao() {
		switch (configuration.getStorageType()) {
			case MARIADB:
				return SchemaHistoryMariaDBDao.class;
			case MYSQL:
				return SchemaHistoryMySQLDao.class;
			case POSTGRESQL:
				return SchemaHistoryPostgreSQLDao.class;
			case SQLITE:
				return SchemaHistorySQLiteDao.class;
			case H2:
				return SchemaHistoryH2Dao.class;
			default:
				return null;
		}
	}
	
	/**
	 * Exception generated by missing migration table
	 */
	public static class MissingMigrationTableException extends RuntimeException {
		MissingMigrationTableException(String text) {
			super(text);
		}
	}
}
